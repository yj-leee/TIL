

## abstraction

> 객체지향 (추상화) 쉽게 이해하기


커피머신과 커피
커피머신은 버튼을 누르면 커피를 먹을 수 있게 해준다. 하지만 사실 커피머신은 복잡한 기계이다. 이렇게 어떤것을 사용할 때 몰라도 되는 부분은 감추고 꼭 알아야 하는 부분만 드러내는 것을 추상화 라고 한다.

예를 들어, 변수나 함수를 쓰는것도 추상화이다.
변수의 값을 한번 설정하면 그 뒤로는 값을 몰라도 되기 때문이다.
함수는 이름과 파라미터 만 알면 사용할 수 있도록 해주기 때문이다. 
추가적으로 클래스를 쓰는것도 추상화이다.

추상화를 클래스에 적용하면 좋은점
1. 동료 개발자가 내가 정의한 클래스를 더 잘 사용할 수 있다.
2. 시간이 지나 자신이 사용할 때도 더 잘 사용할 수 있다.

추상화를 잘하는법
1. 변수 이름 잘짓기
2. 독스트링 문서화

파이썬은 동적 타입 언어이다. 이 말은 변수의 타입을 따로 정하지 않아도 된다는 뜻
변수 이름 뒤에 클론 : 을 쓰고 타입을 써주면 됩니다.


# 데코레이터를 이용한 캡슐화



> 파이썬은 캡슐화를 지원하지 않는다?


#### `@property` 데코레이터를 이용한 캡슐화
파이썬 개발자들은 _언더바 한개로 경고 표시를 함으로써 캡슐화를 한다.  
사실 파이썬에서는 캡슐화를 꼭 지켜야 한다는 의식이 약한 편입니다.  
그러니까 캡슐화를 하지 않는것도 괜찮고 하는것도 괜찮다.  
그런데 만약 캡슐화를 하지 않았는데 나중에 어떤 변수를 숨기고 싶어지면 어떻게 할까?  



// reference  
https://www.daleseo.com/python-property/



> 메소드를 통한 캡슐화

#### 객체를 사용할 땐 최대한 메소드로 
변수를 직접 가져다 쓰는것은 좋지 않다.   
유지보수를 어렵게 만든다.  
클래스를 만드는 개발자와 사용하는 개발자가 모두 신경을 써야 하는 부분이다.  
변수에 직접 접근해서 사용하는걸 최소화할수록 유지 보수하기 쉬운 코드를 만들 수 있다.  



> 객체지향 (캡슐화)

1. 객체의 일부 구현내용에 대한 외부로부터의 직접적인 액세스를 차단한다.  
2. 객체의 속성과 그것을 사용하는 행동을 하나로 묶는 것.  

외부에서 접근 차단하는법 변수나 함수 앞에 __를 붙인다.  
￼

변수에 접근하기 위해 접근이 가능하도록 메소드를 따로 만든다.!  
자바의 getter, setter   
￼




# 상속

파이썬에서 모든 클래스는 builtins.opject 클래스를 자동으로 상속받는다.  
상속이란 두 클래스 사이에 부모 자식 관계를 설정하는 것이다.  
자식 클래스는 부모 클래스의 모든 변수와 메소드를 물려 받을 수 있다.  

장점 코드의 중복을 없애줄 수 있다.

```
# isinstance

isinstance(검사할 인스턴스의 이름, 기준 클래스의 이름)  
# 함수의 첫번째 파라미터로 들어온 이름이 기준 클래스의 인스턴스인지를 알려준다.  

```

```
# issubclass

issubclass(검사할 클래스의 이름, 기준 클래스의 이름)
# 첫번째 파라미터로 들어온 검사할 클래스의 이름이 기준 클래스의 자식 클래스인지를 알려주는 함수

```

# 오버라이딩

자식 클래스가 부모 클래스로부터 물려받은 내용을 자신에 맞게 변경하는것  

```
# super
# 부모 클래스의 메소드를 호출할 수 있다.

class Cashier(Employee):
  def __init(selt, name, wage, number_sold):
    super().__init__(name, wage)
    self.number_sold = number_sold

```



# 다형성

어떤 변수가 여러 종류의 인스턴스를 가리키게 해서 다형성을 가지게 할 수 있다.  
하지만 그 인스턴스에 어떤 메소드를 호출했을 때  
인스턴스가 그 메소드를 갖고 있어야만 다형성이 성립된다.  
메소드 호출 전 isinstance 함수로 어떤 클래스의 인스턴스가 맞는지 미리 확인해야 한다.  

# 추상 클래스

상속을 통해 메소드를 사용하려고 할 때 자식 클래스가 오버라이딩을 하지 않는 경우가 발생할 수 있다.  
이 점을 추상 클래스로 해결할 수 있다.  
아래 pass 는 자식 클래스가 알아서 오버라이딩 해서 사용하라는 의미이다.

추상클래스는 인스턴스를 직접 생성하려고 쓰는 클래스가 아니라  
여러 클래스들의 공통점을 담아두고, 다른 클래스들이 상속받는 부모 클래스가 될 목적으로 존재한다.  


```python
from abc import ABC, abstractmethod

class Shape(ABC):
  @abstractmethod
  def area(self):
    pass
  @abstractmethod
  def perimeter(self):
    pass
```






